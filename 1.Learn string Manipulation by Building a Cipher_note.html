<html><head><title>python
1.Learn string Manipulation by Building a Cipher</title></head><body><ol><li>python
1.Learn string Manipulation by Building a Cipher<p>text = 'mrttaqrhknsw ih puggrur'
custom_key = 'happycoding'

def vigenere(message, key, direction=1):
    key_index = 0
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    final_message = ''

    for char in message.lower():

        # Append any non-letter character to the message
        if not char.isalpha():
            final_message += char
        else:        
            # Find the right key character to encode/decode
            key_char = key[key_index % len(key)]
            key_index += 1

            # Define the offset and the encrypted/decrypted letter
            offset = alphabet.index(key_char)
            index = alphabet.find(char)
            new_index = (index + offset*direction) % len(alphabet)
            final_message += alphabet[new_index]
    
    return final_message

def encrypt(message, key):
    return vigenere(message, key)
    
def decrypt(message, key):
    return vigenere(message, key, -1)

print(f'\nEncrypted text: {text}')
print(f'Key: {custom_key}')
decryption = decrypt(text, custom_key)
print(f'\nDecrypted text: {decryption}\n')</p><ol><li>len()<ol><li>text = 'Hello World'
print(len(text))<ol><li>11</li></ol></li><li>抓取現有資料中的長度</li></ol></li><li>[ ]<ol><li>text = 'Hello World'
print(text[6])<ol><li>W</li></ol></li><li>text = 'Hello World'
print(text[-1])<ol><li>d</li></ol></li><li>抓取字串中指定位子的字元</li></ol></li><li>type()<ol><li>text = 'Hello World'
print(type(text))<ol><li>&lt;class 'str'&gt;</li></ol></li><li>讀取資料是屬於哪種格式</li></ol></li><li>.find<ol><li>text = 'Hello World'
shift = 3
alphabet = 'abcdefghijklmnopqrstuvwxyz'
print(alphabet.find('z'))<p>利用.find（）找出我要</p><ol><li>25</li></ol></li><li>text = 'Hello World'
shift = 3
alphabet = 'abcdefghijklmnopqrstuvwxyz'
index = alphabet.find(text[0])
print(index)<ol><li>If the character is not
found, it returns -1</li><li>-1</li></ol></li><li>找出你要的字串的所在位置</li></ol></li><li>.index</li><li>.lower<ol><li>text = 'Hello World'
shift = 3
alphabet = 'abcdefghijklmnopqrstuvwxyz'
index = alphabet.find(text[0])
//index = alphabet.find(text[0].lower())
print(index)
print(text.lower())<ol><li>-1
hello world</li></ol></li><li> 將所有的字串轉換成小寫</li></ol></li><li>for<ol><li>char<ol><li>message = "HELLO"
for char in message:
    print(char)<ol><li>H
E
L
L
O</li></ol></li><li>在這段代碼中，for char in message: 這一行的意思是對字符串
message 中的每個字符進行迭代。在每次迭代中，char
變量將被設置為 message 中的下一個字符。</li></ol></li><li>Example<ol><li>text = 'Hello World'
shift = 3
alphabet = 'abcdefghijklmnopqrstuvwxyz'
for I in text:
   print(i)<ol><li>H
e
l
l
o
 
W
o
r
l
d</li></ol></li><li>text = 'Hello World'
shift = 3
alphabet = 'abcdefghijklmnopqrstuvwxyz'

for char in text:
    index = alphabet.find(char)
    print(char,index)<ol><li>H -1
e 4
l 11
l 11
o 14
  -1
W -1
o 14
r 17
l 11
d 3</li></ol></li></ol></li></ol></li><li>if<ol><li>comparison operators</li><li>Example<ol><li>for char in text.lower():
    if char==" ":
     print('space!')
    index = alphabet.find(char)
    new_index = index + shift
    encrypted_text += alphabet[new_index]
    print('char:', char, 'encrypted text:', encrypted_text)<ol><li>char: h encrypted text: k
char: e encrypted text: kh
char: l encrypted text: kho
char: l encrypted text: khoo
char: o encrypted text: khoor
space!
char:   encrypted text: khoorc
char: w encrypted text: khoorcz
char: o encrypted text: khoorczr
char: r encrypted text: khoorczru
char: l encrypted text: khoorczruo
char: d encrypted text: khoorczruog</li></ol></li><li>if char.isalpha():<ol><li>#True</li></ol></li><li>if not char.isalpha():<ol><li>#False</li></ol></li><li>如果不等於&gt;&gt;not 表示否定 <ol><li>text = 'Hello Zaira!'
custom_key = 'python'

def vigenere(message, key, direction=1):
    key_index = 0
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    final_message = ''

    for char in message.lower():
       # Append any non-letter character to the message
        if not char.isalpha():
            final_message += char
            
        else:        
            # Find the right key character to encode/decode
            key_char = key[key_index % len(key)]
            key_index += 1

            # Define the offset and the encrypted/decrypted letter
            offset = alphabet.index(key_char)
            index = alphabet.find(char)
            new_index = (index + offset*direction) % len(alphabet)
            final_message += alphabet[new_index]
    
    return final_message
    
encryption = vigenere(text, custom_key)
print(encryption)
decryption = vigenere(encryption, custom_key, -1)
print(decryption)
<ol><li>wcesc mpgkh!
hello zaira!</li></ol></li></ol></li></ol></li></ol></li><li>def function_name():
    &lt;code&gt;
    return parameter
    pass #在最後一行加pass可以避免除錯時<ol><li>Example<ol><li>text = 'Hello Zaira'
shift = 3

def caesar(message, offset):
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    encrypted_text = ''

    for char in message.lower():
        if char == ' ':
            encrypted_text += char
        else:
            index = alphabet.find(char)
            new_index = (index + offset) % len(alphabet)
            encrypted_text += alphabet[new_index]
    print('plain text:', message)
    print('encrypted text:', encrypted_text)

caesar(text, shift)
caesar(text, 13)<ol><li>plain text: Hello Zaira
encrypted text: khoor cdlud
plain text: Hello Zaira
encrypted text: uryyb mnven</li></ol></li><li>text = 'Hello Zaira'
custom_key = 'python'

def vigenere(message, key):
    key_index = 0
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    encrypted_text = ''

    for char in message.lower():
    
        # Append space to the message
        if char == ' ':
            encrypted_text += char
        else:        
            # Find the right key character to encode
            key_char = key[key_index % len(key)]
            key_index += 1

            # Define the offset and the encrypted letter
            offset = alphabet.index(key_char)
            index = alphabet.find(char)
            new_index = (index + offset) % len(alphabet)
            encrypted_text += alphabet[new_index]
    
    return encrypted_text
    
encryption = vigenere(text, custom_key)
print(encryption)<ol><li>wcesc mpgkh</li></ol></li><li>def foo():
    return 'spam'<ol><li>注意return 的前面要有空格</li><li>主要用來回傳定義裡面的數值</li></ol></li></ol></li><li>def foo(a, b, c=value):
    &lt;code&gt;<ol><li>Example<ol><li>text = 'Hello Zaira'
custom_key = 'python'
def vigenere(message, key, direction=1):
    key_index = 0
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    final_message = ''

    for char in message.lower():
    
        # Append space to the message
        if char == ' ':
            final_message += char
        else:        
            # Find the right key character to encode/decode
            key_char = key[key_index % len(key)]
            key_index += 1

            # Define the offset and the encrypted/decrypted letter
            offset = alphabet.index(key_char)
            index = alphabet.find(char)
            new_index = (index + offset*direction) % len(alphabet)
            final_message += alphabet[new_index]
    
    return final_message
    
encryption = vigenere(text, custom_key) #這定義為預設
print(encryption)
decryption = vigenere(encryption, custom_key, -1)
print(decryption)</li></ol></li><li>Ｃ=value ，表示為預設值 ex;def vigenere(message, key, direction=1)
所以要執行這方程式時可以不用輸入第三個值。encryption = vigenere(text, custom_key) </li></ol></li><li>在後續結尾要加pass表示def的最後一行</li></ol></li><li>.isalpha()<ol><li>Example<ol><li>'freeCodeCamp'.isalpha()
# True<ol><li>if char.isalpha():<ol><li>#True</li></ol></li><li>if not char.isalpha():<ol><li>#False</li></ol></li></ol></li></ol></li></ol></li><li>print()<ol><li>We call "f-strings"
print(f,"")<ol><li>print('Encrypted text: ' + text)
print('Key: ' + custom_key)
print(f'Encrypted text: {text}')<ol><li>Encrypted text: mrttaqrhknsw ih puggrur
Key: python
Encrypted text: mrttaqrhknsw ih puggrur</li></ol></li><li>結果會是相同的，{ } 裡面的是變數，
他會自動轉換，要使用f-strings</li></ol></li><li>\n    跳至下一行<ol><li>print(f'\nEncrypted text: {text}')
print(f'Key: {custom_key}')<ol><li>
Encrypted text: mrttaqrhknsw ih puggrur
Key: python</li></ol></li></ol></li></ol></li></ol></li><li>單字學習<ol><li>Caesar cipher
凱撒密碼
シーザー<ol><li>text = 'Hello World'
shift = 3
alphabet = 'abcdefghijklmnopqrstuvwxyz'
index = alphabet.find(text[0].lower())
print(index)
shifted = alphabet[index+shift]
print(shifted)<ol><li>7
k</li></ol></li><li>encrypted charactor</li><li>Vigenère cipher
ヴィジュネル暗号
維吉尼亞密碼</li></ol></li><li>IndentationError<ol><li>表示在語法中有問題時，終端機會顯示這個詞<ol><li>for i in text:</li><li>for 迴圈還沒有寫完</li></ol></li></ol></li><li>Modulo operator<ol><li>%<ol><li>In this case, the modulo operator (%) can be used to return the
remainder of the division between two numbers. For example:
5 % 2 is equal to 1, because 5 divided by 2 has a quotient of 2
and a remainder of 1.<ol><li>text = 'Hello Zaira'
shift = 3
alphabet = 'abcdefghijklmnopqrstuvwxyz'
encrypted_text = ''

for char in text.lower():
    if char == ' ':
        encrypted_text += char
    else:
        index = alphabet.find(char)
        new_index = (index + shift)%26 #因為資料最大只有26，程式中是從0開始計算，所以只有0~25，超過alphabet數字，我們除以26來取餘數
        print(index+shift,new_index)
        encrypted_text += alphabet[new_index]
    print('char:', char, 'encrypted text:', encrypted_text)<ol><li>10 10
char: h encrypted text: k
7 7
char: e encrypted text: kh
14 14
char: l encrypted text: kho
14 14
char: l encrypted text: khoo
17 17
char: o encrypted text: khoor
char:   encrypted text: khoor 
28 2
char: z encrypted text: khoor c
3 3
char: a encrypted text: khoor cd
11 11
char: I encrypted text: khoor cdl
20 20
char: r encrypted text: khoor cdlu
3 3
char: a encrypted text: khoor cdlud</li></ol></li><li>text = 'Hello Zaira'
shift = 3
alphabet = 'abcdefghijklmnopqrstuvwxyz'
encrypted_text = ''

for char in text.lower():
    if char == ' ':
        encrypted_text += char
    else:
        index = alphabet.find(char)
        new_index = (index + shift) % len(alphabet)#直接抓取資料中的長度
        encrypted_text += alphabet[new_index]
    print('char:', char, 'encrypted text:', encrypted_text)</li></ol></li></ol></li></ol></li></ol></li></ol></body></html>